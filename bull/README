- How to compile this program:

$ ocamlbuild main.native

----------------------------------------------------------------------------------------------------

- How to run this program:

Preferably:
$ rlwrap ./main.native [initfile]
(see http://linux.die.net/man/1/rlwrap)

Or:
$ ./main.native [initfile]

----------------------------------------------------------------------------------------------------

- List of commands:
Help.				     for a list of commands
Load "file".		      	     for loading a script file
Axiom term : type.	    	     define a constant or an axiom
Lemma proofname : term.        	     start an interactive proof (not implemented yet)
Definition name [: type] := term.    define a term
Print name. 	       	  	     print the definition of name
Printall. 			     print all the signature (axioms and definitions)
Compute name.			     normalize name and print the result
Quit. 				     quit

Names are composed of any alphanumeric symbol, _ and '.
Terms and types have the same syntax.
Comments are enclosed between (* and *), Ã  la ocaml.

Syntax of terms:
| Type				# sort Type
| name				# identifier
| forall x : term, term		# dependent product
| term -> term	   		# non-dependent product
| fun x : term => type		# lambda-abstraction
| sforall x : term, term	# relevant dependent product
| term >> term	    		# relevant non-dependent product
| sfun x : term => term		# relevant lambda-abstraction
| term term    	  		# application
| term & term			# intersection of types
| term | term			# union of types
| <term, term>			# strong pair
| proj_l term			# left projection of a strong pair
| proj_r term			# right projection of a strong pair
| return term with term		# strong co-pair
| inj_l term term   	  	# left injection
| inj_r term term		# right injection

- Relevant lambda-abstractions only type terms equivalent to the identity function.
- Strong pair has an intersection type and both its arguments must share the same essence.
- The first argument of the strong co-pair must be its type (of the shape forall x : a | b, c),
  and the second argument must have type (forall x : a, c) & (forall x : b, c).
- The first argument of the injection is the type that is added in a union to the type of the
  second argument.

----------------------------------------------------------------------------------------------------

Example of user session:
$ rlwrap ./main.native
Welcome to Bull, an experimental LF-based proof checker with set-inspired types.
Type "Help." for help.

> Axiom a : Type.
a is assumed.

> Axiom b : Type.
b is assumed.

> Axiom c : Type.
c is assumed.

> Definition f := < fun x : a => x, fun y : b => y >.
f is defined.

> Definition g := sfun x : a => return (a | b) -> (b | a) with < fun y : a => inj_r b (proj_l f y), fun z : b => inj_l a (proj_r f z) > inj_l b x.
g is defined.

> Compute g.
sfun x : a, return a | b -> b | a with < fun y : a => inj_r b (proj_l < fun x : a => x, fun y : b => y > y), fun z : b => inj_l a (proj_l < fun x : a => x, fun y : b => y > z) > inj_l b x : a >> b | a
	essence = fun x => x : a >> b | a
> Quit.

----------------------------------------------------------------------------------------------------

intersection_union.script is the implementation of the Barbanera-Dezani-De'Liguoro type system. Type
> Load "intersection_union.script".
in a user session to load it. Or alternatively, launch the program with "intersection_union.script" as a command-line argument.

----------------------------------------------------------------------------------------------------

Source code:

main.ml describes the REPL
lexer.mll and parser.mly describes the lexer and the parser.
utils.ml describes the types.
bruijn.ml implements functions related to de Bruijn indexes.
printer.ml implements function printers and error printers.
reduction.ml describes the normalization algorithm.
reconstruction.ml describes the reconstruction algorithm.

----------------------------------------------------------------------------------------------------

