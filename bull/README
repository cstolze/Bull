- How to compile this program:

$ ocamlbuild main.native

----------------------------------------------------------------------------------------------------

- How to run this program:

Preferably:
$ rlwrap ./main.native [initfile]
(see http://linux.die.net/man/1/rlwrap)

Or:
$ ./main.native [initfile]

----------------------------------------------------------------------------------------------------

- List of commands:
Help.				     for a list of commands
Load file.		      	     for loading a script file
Axiom term : type.	    	     define a constant or an axiom
Lemma proofname : term.        	     start an interactive proof (not implemented yet)
Definition name [: type] := term.    define a term
Print name. 	       	  	     print the definition of name
Printall. 			     print all the signature (axioms and definitions)
Compute name.			     normalize name and print the result
Quit. 				     quit

Names are composed of any alphanumeric symbol, _ and '.
Terms and types have the same syntax.

Syntax of terms:
| Type				# sort Type
| name				# identifier
| $				# omega, the universal type
| forall x : term, term		# dependent product
| term -> term	   		# non-dependent product
| fun x : term => type		# lambda-abstraction
| term term    	  		# application
| term & term			# intersection of types
| term | term			# union of types
| <term, term>			# strong pair
| proj_l term			# left projection of a strong pair
| proj_r term			# right projection of a strong pair
| return term with <term, term> # strong co-pair
| inj_l term term   	  	# left injection
| inj_r term term		# right injection

----------------------------------------------------------------------------------------------------

Example of user session: (TO UPDATE)
$ rlwrap ./main.native
Type "Help;" for help.

> Type a : Type;
> Type b : Type;
> Type c : Type;
> Constant cst : c;
> Definition f = <\x:a.cst & \y:b.cst>;
f = < (\x : a. cst) & (\y : b. cst) > : (a -> c) & (b -> c)

> Definition g = \ x : a . < \ y : a . proj_l f y | \ z : b . proj_r f z # inj_l x >;
g = \x : a. < \y : a. ((proj_l f) y) | \z : b. ((proj_r f) z) # inj_l x > : a -> c

> Compute g;
\$x : a. cst

> Quit;

----------------------------------------------------------------------------------------------------

Source code: (TO UPDATE)

main.ml describes the REPL
lexer.mll and parser.mly describes the lexer and the parser
utils.ml describes the types
reduction.ml describes the normalization algorithm
inference.ml describes the reconstruction algorithm
proof.ml describes the proof-related functions

----------------------------------------------------------------------------------------------------

TODO:

Implement subtyping.
Implement a refiner.
Implement a proof system.
