Type int : Type;

Definition c0 = < \f : int -> int. \ x : int. x & \f : (int -> int) -> int -> int. \ x : int -> int. x>;
Definition cS = \ n : ((int -> int) -> int -> int) & (((int -> int) -> int -> int) -> (int -> int) -> int -> int). <\ f : int -> int. \ x : int. f ((proj_l n) f x) & \f : (int -> int) -> int -> int. \ x : int -> int. f ((proj_r n) f x)>;

Definition add = \m : (int -> int) -> (int -> int). \n : (int -> int) -> (int -> int). \f : int -> int. \x : int. m f (n f x);
Definition mul = \m : (int -> int) -> (int -> int) . \n : (int -> int) -> (int -> int) . \f : int -> int . m (n f);
Definition exp = \m : (int -> int) -> (int -> int). \n : ((int -> int) -> (int -> int)) -> ((int -> int) -> (int -> int)). n m;

Constant 0 : int;
Constant S : int -> int;

Definition c2 = cS (cS c0);
Definition c3 = cS c2;
Definition c4 = cS c3;
Definition c5 = cS c4;
Definition c6 = cS c5;
Definition c7 = cS c6;
Definition c10 = cS (cS (cS c7));

Type equal : ! x : int. ! y : int. Type;
Constant eq_refl : ! x : int. equal x x;

Proof eqlemma : (equal (add (proj_l c3) (proj_l c7) S 0) (proj_l c10 S 0)) & (equal (mul (proj_l c5) (proj_l c2) S 0) (add (proj_l c4) (proj_l c6) S 0));

inter;
exact (eq_refl (proj_l c10 S 0));
exact (eq_refl (proj_l c10 S 0));