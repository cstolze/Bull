
(* dependent de Bruijn indexes : FAIL *)
(*Inductive Signature : Set :=
| emptysig : Signature (* <> *)
| tcons : forall (s : Signature) (c : Context), Kind s c -> Signature (* \Sigma, a : K (context is supposed empty, but I do not force it here, as I am declaring the syntax of the signature, not the semantics) *)
| ccons : forall (s : Signature) (c : Context), Sigma s c -> Signature (* \Sigma, c : A , same remark as above *)
with
Context : Signature -> Set :=
| emptyctx : forall s : Signature, Context s (* <> *)
| vcons : forall (s : Signature) (c : Context), Sigma s c -> Context (* \Gamma, x : A *)
with
Kind : Signature -> Context -> Set :=
| type : forall (s : Signature) (c : Context), Kind s g (* Type *)
| kprod : forall (s : Signature) (c : Context) (x : Sigma), Kind s (vcons x c) -> Kind s c (* \Pi x : A. K *) (* "->" is a special form of "\Pi" *)
with
Sigma : Signature -> Context -> Set :=
| prod : forall (s : Signature) (c : Context) (x : Sigma), Sigma s (vcons x c) -> Sigma s c (* \Pi x : A. B *)
| lamb : forall (s : Signature) (c : Context) (x : Sigma), Sigma s (vcons x c) -> Sigma s c (* \Lambda x : A. B *)
| sapp : forall (s : Signature) (c : Context), Sigma s c -> Delta s c -> Sigma s c (* A M *)
| sand : forall (s : Signature) (c : Context), Sigma s c-> Sigma s c -> Sigma s c (* A \cap B *)
| sor : forall (s : Signature) (c : Context), Sigma s c -> Sigma s c -> Sigma s c (* A \cup B *)
| svar : forall (s : Signature) (c : Context) (x : Sigma), pointer s c x -> Sigma s c (* a *)
| om : forall (s : Signature) (c : Context), Sigma s c (* \omega *)
(* | wildcard : Sigma s c (* ? (for type inference purposes) *) *)
with
Delta : Signature -> Context -> Set :=
| var : forall (s : Signature) (c : Context) (x : Sigma), pointer s c x -> Delta s c (* x *)
| star : forall (s : Signature) (c : Context), Delta s c (* * *)
| abst : forall (s : Signature) (c : Context) (x : Sigma), Delta s (vcons x c) -> Delta s c (* \lambda x : A. M *)
| appl : forall (s : Signature) (c : Context), Delta s c -> Delta s c -> Delta s c (* M N *)
| and : forall (s : Signature) (c : Context), Delta s c -> Delta s c -> Delta s c (* <M, N> *)
| pr1 : forall (s : Signature) (c : Context), Delta s c -> Delta s c (* pr1 M *)
| pr2 : forall (s : Signature) (c : Context), Delta s c -> Delta s c (* pr2 M *)
| or : forall (s : Signature) (c : Context) (x y : Sigma), Delta s (vcons x c) -> Delta s (vcons y c) -> Delta s c (* [\lambda x : A. M, \lambda y : B. N] M' *)
| in1 : forall (s : Signature) (c : Context), Delta s c -> Delta s c (* in1 M *)
| in2 : forall (s : Signature) (c : Context), Delta s c -> Delta s c (* in2 M *)
.*)

(*Inductive Kind : Set :=
| type : Kind (* Type *)
| kprod : Id -> Sigma -> Kind (* \Pi x : A. K *)
with
Sigma : Set :=
(* | func : Sigma -> Sigma -> Sigma (* A -> B *) *)
| prod : Id -> Sigma -> Sigma -> Sigma (* \Pi x : A. B *)
| lamb : (Id -> Sigma -> Sigma) ->Sigma (* \Lambda x : A. B *)
| sapp : Sigma -> Delta -> Sigma (* A M *)
| sand : Sigma -> Sigma -> Sigma (* A \cap B *)
| sor : Sigma -> Sigma -> Sigma (* A \cup B *)
| svar : Id -> Sigma (* a *)
| om : Sigma (* \omega *)
| wildcard : Sigma (* ? (for type inference purposes) *)
with
Delta : Set :=
| var : Id -> Delta (* x *)
| star : Delta (* * *)
| abst : (Id -> Sigma -> Delta) -> Delta (* \lambda x : A. M *)
| appl : Delta -> Delta -> Delta (* M N *)
| and : Delta -> Delta -> Delta (* <M, N> *)
| pr1 : Delta -> Delta (* pr1 M *)
| pr2 : Delta -> Delta (* pr2 M *)
| or : Id -> Sigma -> Delta -> Id -> Sigma -> Delta -> Delta (* [\lambda x : A. M, \lambda y : B. N] M' *)
| in1 : Delta -> Delta (* in1 M *)
| in2 : Delta -> Delta (* in2 M *)
.*)
(* todo : free variables *)

(* alpha-conversion (todo: remplacer par une substitution) *)
(*Fixpoint alphaconv (x x' : Id) (d : Delta) : Delta :=
  match d with
    | var y => if (equal x y) then var x' else var y
    | star : Delta => star
    | abst y d' => if (equal x y) then abst y d' else abst y (alphaconv x x' d')
    | appl d' d'' => appl (alphaconv x x' d') (alphaconv x x' d'')
    | and d' d'' => and (alphaconv x x' d') (alphaconv x x' d'')
    | pr1 d' => pr1 (alphaconv x x' d')
    | pr2 d' => pr2 (alphaconv x x' d')
    | or y d' z d'' d''' => if (equal x y) then
                              if (equal x z) then
                                or y d' z d'' (alphaconv x x' d''')
                              else
                                or y d' z (alphaconv x x' d'') (alphaconv x x' d''')
                            else
                              if (equal x z) then
                                or y (alphaconv x x' d') z d'' (alphaconv x x' d''')
                              else
                                or y (alphaconv x x' d') z (alphaconv x x' d'') (alphaconv x x' d''')
    | in1 d' => in1 (alphaconv x x' d')
    | in2 d' => in2 (alphaconv x x' d')
  end.
*)

(* delta-term equivalence *)
(* from now, only alpha-beta-eta *)
(*Inductive Equiv : Delta -> Delta -> Prop :=
| erefl : forall d : Delta, Equiv d d.
| esym : forall d d' : Delta, Equiv d' d -> Equiv d d'.
| etrans : forall d d' d'' : Delta,  Equiv d d' -> Equiv d' d'' -> Equiv d d''
| eeta :  forall (a : Id) (d : Delta), Equiv d (lam a (app d (var a)))
| ebeta : (* todo : beta-redex *)
| eapp : forall d d' d1 d1' : Delta, Equiv d d1 -> Equiv d' d1' -> Equiv (app d d') (app d1 d1')
| elam : (* todo : alpha-conv *)
| eand : forall d d' d1 d1' : Delta, Equiv d d1 -> Equiv d' d1' -> Equiv (and d d') (and d1 d1')
| epr1 : forall d d' : Delta, Equiv d d' -> Equiv (pr1 d) (pr1 d')
| epr2 : forall d d' : Delta, Equiv d d' -> Equiv (pr2 d) (pr2 d')
| eor : (* todo : alpha-conv *)
| ein1 : forall d d' : Delta, Equiv d d' -> Equiv (in1 d) (in1 d')
| ein2 : forall d d' : Delta, Equiv d d' -> Equiv (in2 d) (in2 d')
.*)

(*Inductive Equiv (var : Set) : Delta var -> Delta var -> Prop :=
| erefl : forall d : Delta var, Equiv var d d
| esym : forall d d' : Delta var, Equiv var d' d -> Equiv var d d'
| etrans : forall d d' d'' : Delta var,  Equiv var d d' -> Equiv var d' d'' -> Equiv var d d''
| eeta :  forall (d : Delta var), Equiv var d (abst _ (fun x : var => (appl _ d (vari _ x))))
| ebeta : forall (d : Delta var -> Delta (Delta var)) (d' : Delta var), Equiv var (appl _ (squashd _ (abst _ d)) d') (substi _ d d')
| eapp : forall d d' d1 d1' : Delta var, Equiv var d d1 -> Equiv var d' d1' -> Equiv var (appl _ d d') (appl _ d1 d1')
| elam : forall (d d' : var -> Delta var), (forall x : var, Equiv var (d x) (d' x)) -> Equiv var (abst var d) (abst var d')
| eand : forall d d' d1 d1' : Delta var, Equiv var d d1 -> Equiv var d' d1' -> Equiv var (and _ d d') (and _ d1 d1')
| epr1 : forall d d' : Delta var, Equiv var d d' -> Equiv var (pr1 _ d) (pr1 _ d')
| epr2 : forall d d' : Delta var, Equiv var d d' -> Equiv var (pr2 _ d) (pr2 _ d')
| eor : forall (d d' d1 d1' : var -> Delta var) (d'' d1'' : Delta var), (forall x : var, Equiv var (d x) (d1 x)) -> (forall x : var, Equiv var (d' x) (d1' x)) -> Equiv var d'' d1'' -> Equiv var (or var d d' d'') (or var d1 d1' d1'')
| ein1 : forall d d' : Delta var, Equiv var d d' -> Equiv var (in1 _ d) (in1 _ d')
| ein2 : forall d d' : Delta var, Equiv var d d' -> Equiv var (in2 _ d) (in2 _ d')
.*)
